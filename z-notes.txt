Perfect! We’ll go component by component, focusing on:
	•	Safe numeric input handling (parseFloat, Math.max(0, …) for amounts).
	•	Consistent key usage in lists.
	•	Avoiding state overwrites.
	•	Preventing unnecessary re-renders.
	•	Clear, maintainable JSX.

⸻

1. BottomSheet.jsx (refactored)


✅ Fixes:
	•	Prevents clicks inside the sheet from closing it (stopPropagation).
	•	Conditional title rendering.

⸻

2. AddExpenseForm.jsx (refactored)

import React, { useState } from "react";

export default function AddExpenseForm({ onAdd, onClose }) {
  const [description, setDescription] = useState("");
  const [amount, setAmount] = useState("");

  const handleSubmit = (e) => {
    e.preventDefault();
    const amt = parseFloat(amount);
    if (!description || isNaN(amt) || amt <= 0) return alert("Enter valid data");
    onAdd(description.trim(), amt);
    setDescription("");
    setAmount("");
    onClose();
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        placeholder="Expense Description"
        value={description}
        onChange={(e) => setDescription(e.target.value)}
        className="border p-2 mb-2 w-full"
        required
      />
      <input
        type="number"
        placeholder="Amount"
        value={amount}
        onChange={(e) => setAmount(e.target.value)}
        className="border p-2 mb-2 w-full"
        min="0"
        step="0.01"
        required
      />
      <button type="submit" className="bg-blue-500 text-white p-2 w-full">
        Add Expense
      </button>
    </form>
  );
}

✅ Fixes:
	•	Numeric parsing with parseFloat.
	•	Prevents negative or NaN values.
	•	Clears form after submission.

⸻

3. AddGoalForm.jsx (refactored)

import React, { useState } from "react";

export default function AddGoalForm({ onAdd, onClose }) {
  const [name, setName] = useState("");
  const [target, setTarget] = useState("");

  const handleSubmit = (e) => {
    e.preventDefault();
    const amt = parseFloat(target);
    if (!name || isNaN(amt) || amt <= 0) return alert("Enter valid data");
    onAdd({ name: name.trim(), target: amt });
    setName("");
    setTarget("");
    onClose();
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        placeholder="Goal Name"
        value={name}
        onChange={(e) => setName(e.target.value)}
        className="border p-2 mb-2 w-full"
        required
      />
      <input
        type="number"
        placeholder="Target Amount"
        value={target}
        onChange={(e) => setTarget(e.target.value)}
        className="border p-2 mb-2 w-full"
        min="0"
        step="0.01"
        required
      />
      <button type="submit" className="bg-green-500 text-white p-2 w-full">
        Add Goal
      </button>
    </form>
  );
}

✅ Fixes:
	•	Same numeric validation as AddExpenseForm.
	•	Clears form after submit.
	•	Avoids empty or invalid goals.

⸻

4. ExpenseList.jsx (refactored)

import React from "react";

export default function ExpenseList({ expenses, onClear, onDelete }) {
  if (!expenses.length) return <p>No expenses yet.</p>;

  return (
    <ul>
      {expenses.map((e) => (
        <li key={e.id} className="flex justify-between items-center border p-2 mb-2">
          <div>
            <span className="font-semibold">{e.description}</span> - {e.amount.toFixed(2)}
          </div>
          <div>
            {e.status === "pending" && (
              <button
                onClick={() => onClear(e.id)}
                className="bg-green-500 text-white px-2 mr-2"
              >
                Clear
              </button>
            )}
            <button
              onClick={() => onDelete(e.id)}
              className="bg-red-500 text-white px-2"
            >
              Delete
            </button>
          </div>
        </li>
      ))}
    </ul>
  );
}

✅ Fixes:
	•	Proper key usage with id.
	•	Prevents modifying cleared expenses incorrectly.

⸻

I can continue with ClearanceList, WishlistList, AllocationDisplay, and SavingsGoal components, applying the same numeric checks, safe state updates, and list key handling.

Do you want me to continue with those next?